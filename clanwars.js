// Generated by CoffeeScript 1.7.1
(function() {
  var Ball, Clan, Game, Reflector, Sprite, World, finish_game_banner, keys, map, mission, start_game_banner;

  keys = {
    LEFT: 37,
    RIGHT: 39,
    UP: 38,
    DOWN: 40
  };

  mission = "На Империю напал неизвестный враг! Вы попробовали подсчитать общее количество войск, но сбились со счёта на 13-й сотне. Вам требуется разбить их всех до одного и опровергнуть известное высказывание \"всё будет зелёным\". Для управления вашими войсками используйте клавиши курсора.";

  map = ".\n     ZZZ ZZZ ZZZ  ZZ ZZZ Z Z  ZZ\n       Z Z   Z Z Z    Z  Z Z Z\n      Z  ZZZ ZZ  ZZZ  Z  Z Z  Z\n     Z   Z   Z Z Z Z  Z  Z Z   Z\n     ZZZ ZZZ Z Z  ZZ ZZZ  Z  ZZ\n\n              ZZZZ     ZZ\n             ZZ       ZZ\n             ZZZ  ZZ ZZ\n             ZZ  ZZZZZ\n             ZZ ZZZZZ\n             ZZ ZZZZZZ\n             ZZ ZZZZZZ\n             ZZZZZZZZ\n             ZZ  ZZZZ\n              ZZ\n               ZZZZ";

  start_game_banner = function(div, callback) {
    div.show().html('<div>' + mission + '</div><a class="btn clanwars-start-btn">start</a>');
    return div.find('.clanwars-start-btn').click(function() {
      div.html('').hide();
      return callback();
    });
  };

  finish_game_banner = function(div, callback) {
    div.show().html('<div>Finished</div>');
    return div.find('.clanwars-finish-btn').click(function() {
      div.html('').hide();
      return callback();
    });
  };

  World = (function() {
    function World(context) {
      var doSleep, gravity;
      gravity = new b2Vec2(0, 2);
      doSleep = true;
      this.world = new b2World(gravity, doSleep);
      this.createBox(0, 300, 10, 600);
      this.createBox(800, 300, 10, 600);
      this.topbox = this.createBox(400, 0, 800, 10);
    }

    World.prototype.step = function() {
      return this.world.Step.apply(this.world, arguments);
    };

    World.prototype.createBox = function(x, y, width, height, options) {
      var body, bodyDef, fixDef, _ref, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      fixDef = new b2FixtureDef;
      fixDef.density = (_ref = options.density) != null ? _ref : 1.0;
      fixDef.friction = (_ref1 = options.friction) != null ? _ref1 : 0.5;
      fixDef.restitution = (_ref2 = options.restitution) != null ? _ref2 : 1;
      bodyDef = new b2BodyDef;
      bodyDef.type = (options.fixed != null) && !options.fixed ? b2Body.b2_dynamicBody : b2Body.b2_staticBody;
      fixDef.shape = new b2PolygonShape;
      fixDef.shape.SetAsBox(width / 30, height / 30);
      bodyDef.position.Set(x / 30, y / 30);
      body = this.world.CreateBody(bodyDef);
      body.CreateFixture(fixDef);
      body.SetUserData(options.userdata);
      return body;
    };

    World.prototype.createBall = function(x, y, options) {
      var body, bodyDef, fixDef;
      if (options == null) {
        options = {};
      }
      fixDef = new b2FixtureDef;
      fixDef.density = 1.0;
      fixDef.friction = 1;
      fixDef.restitution = 1;
      bodyDef = new b2BodyDef;
      bodyDef.type = b2Body.b2_dynamicBody;
      fixDef.shape = new b2CircleShape(7.5 / 30);
      bodyDef.position.Set(x / 30, y / 30);
      body = this.world.CreateBody(bodyDef);
      body.CreateFixture(fixDef);
      body.SetUserData(options.userdata);
      body.SetBullet(true);
      return body;
    };

    World.prototype.checkFinish = function(arg) {
      var b, _ref;
      b = this.world.m_bodyList;
      while (b) {
        if (b != null ? (_ref = b.GetUserData()) != null ? _ref.isClan : void 0 : void 0) {
          return false;
        }
        b = b.m_next;
      }
      return this.finished = true;
    };

    World.prototype.draw = function(context) {
      var b, _ref, _results;
      b = this.world.m_bodyList;
      _results = [];
      while (b) {
        if ((b != null ? (_ref = b.GetUserData()) != null ? _ref.draw : void 0 : void 0) != null) {
          b.GetUserData().draw(context);
        }
        _results.push(b = b.m_next);
      }
      return _results;
    };

    return World;

  })();

  Sprite = (function() {
    function Sprite(ctx, img, x, y, w, h, clips) {
      this.ctx = ctx;
      this.img = img;
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.clips = clips;
      this.currclip = 0;
    }

    Sprite.prototype.draw = function(ctx, x, y, rot) {
      x *= 30;
      y *= 30;
      ctx.translate(x, y);
      ctx.rotate(rot);
      ctx.drawImage(this.img, this.x + this.currclip * this.w, this.y, this.w, this.h, -this.w / 2, -this.h / 2, this.w, this.h);
      ctx.rotate(-rot);
      ctx.translate(-x, -y);
      if (this.animate && this.clips) {
        this.currclip = ~~((Date.now() - this.begin) / 100);
        if (this.currclip >= this.clips) {
          this.animate = false;
          return this.currclip = 0;
        }
      } else if (this.clips) {
        if (Math.random() > 0.999) {
          this.animate = 1;
        }
        return this.begin = Date.now();
      }
    };

    return Sprite;

  })();

  Reflector = (function() {
    function Reflector(world, ctx, img, cols, rows) {
      var pjd;
      this.world = world;
      this.cols = cols;
      this.rows = rows;
      this.sprite = new Sprite(ctx, img, 0, 0, 113, 20);
      this.pos = (this.cols - 4) / 2 * 80;
      this.phys = this.world.createBox(400, 575, 113 / 2, 20 / 2, {
        fixed: false,
        friction: 1,
        userdata: this,
        restitution: 0.88
      });
      this.center = this.world.createBox(400, 575, 5, 5, {
        fixed: false,
        friction: 1,
        density: 400
      });
      this.mass = this.phys.GetMass() + this.center.GetMass();
      this.center.SetLinearDamping(3);
      pjd = new b2RevoluteJointDef();
      pjd.enableLimit = true;
      pjd.lowerAngle = -0.1;
      pjd.upperAngle = 0.1;
      pjd.Initialize(this.center, this.phys, this.center.GetWorldCenter());
      this.world.world.CreateJoint(pjd);
      pjd = new b2PrismaticJointDef();
      pjd.Initialize(this.center, this.world.topbox, this.center.GetWorldCenter(), new b2Vec2(1.0, 0.0));
      this.world.world.CreateJoint(pjd);
    }

    Reflector.prototype.draw = function(ctx) {
      var pos, rot;
      pos = this.phys.GetWorldCenter();
      rot = this.phys.GetAngle();
      return this.sprite.draw(ctx, pos.x, pos.y, rot);
    };

    Reflector.prototype.left = function() {
      return this.move(-1);
    };

    Reflector.prototype.right = function() {
      return this.move(1);
    };

    Reflector.prototype.move = function(dir) {
      var linear, pos;
      linear = this.phys.GetLinearVelocity();
      pos = this.phys.GetWorldCenter();
      if (dir === -1 && pos.x < (113 / 3 * 2) / 30) {
        return;
      }
      if (dir === 1 && pos.x > (800 - 113 / 3 * 2) / 30) {
        return;
      }
      this.phys.ApplyImpulse(new b2Vec2(this.mass * -linear.x, 0), {
        x: pos.x,
        y: pos.y
      });
      this.phys.ApplyImpulse(new b2Vec2(this.mass * dir * 12, this.mass * 0.001), {
        x: pos.x - 1000 / 30 * dir,
        y: pos.y
      });
      return this.sync();
    };

    Reflector.prototype.up = function(time) {
      var dir, pos;
      dir = this.phys.GetAngle() > 0 ? -1 : 1;
      pos = this.phys.GetWorldCenter();
      return this.phys.ApplyImpulse(new b2Vec2(0, this.mass * 0.02), {
        x: pos.x + 1000 / 30 * dir,
        y: pos.y
      });
    };

    Reflector.prototype.down = function(time) {
      var linear, pos;
      pos = this.phys.GetWorldCenter();
      linear = this.phys.GetLinearVelocity();
      return this.phys.ApplyImpulse(new b2Vec2(this.mass * -linear.x, 0), {
        x: pos.x,
        y: pos.y
      });
    };

    Reflector.prototype.ball_hit = function(ball) {

      /*
      		do (ball) ->
      			setTimeout ->
      				phys = ball.phys
      				curvel = phys.GetLinearVelocity()
      				console.log(curvel)
      				curspeed = curvel.Normalize()
      				velChange = 1000 - curspeed
      				impulse = phys.GetMass() * velChange
      				console.log(impulse)
      				curvel.x *= impulse
      				curvel.y *= impulse
      				phys.ApplyImpulse(curvel, phys.GetWorldCenter())
      			, 1000
       */
    };

    Reflector.prototype.sync = function() {

      /*
      		pos = @phys.GetLocalCenter()
      		pos.y = 560
      		rot = @phys.GetRotation()
      		rot -= Math.PI if rot > Math.PI/2
      		rot += Math.PI if rot < -Math.PI/2
      		rot = 0.1 if rot > 0.1
      		rot = -0.1 if rot < -0.1
      		@phys.SetCenterPosition(pos, rot)
      		linear = @phys.GetLinearVelocity()
      		if Math.abs(linear.x) > 300
      			linear.x = if linear.x > 0 then 300 else -300
      			@phys.SetLinearVelocity(linear)
       */
    };

    return Reflector;

  })();

  Ball = (function() {
    function Ball(world, ctx, img, cols, rows) {
      this.world = world;
      this.cols = cols;
      this.rows = rows;
      this.sprite = new Sprite(ctx, img, 0, 30, 15, 15);
      this.x = (this.cols - 2 / 3) / 2;
      this.y = this.rows - 2 + 1 / 3;
      this.phys = this.world.createBall(400, 550, {
        userdata: this
      });
      this.phys.ApplyImpulse(new b2Vec2(0, this.phys.GetMass() * 9), this.phys.GetWorldCenter());
    }

    Ball.prototype.start_left = function() {
      if (this.a == null) {
        return this.a = Math.atan2(-Math.random() * 0.2 - 0.9, -1);
      }
    };

    Ball.prototype.start_right = function() {
      if (this.a == null) {
        return this.a = Math.atan2(-Math.random() * 0.2 - 0.9, 1);
      }
    };

    Ball.prototype.move = function(time) {
      if (this.a == null) {
        return;
      }
      this.x += Math.cos(this.a) * time / 100;
      return this.y += Math.sin(this.a) * time / 100;
    };

    Ball.prototype.draw = function(ctx) {
      var pos, rot;
      pos = this.phys.GetWorldCenter();
      if (pos.y * 30 > 1000) {
        this.respawn();
      }
      rot = this.phys.GetAngle();
      this.sprite.draw(ctx, pos.x, pos.y, rot);
      if (!this.phys.IsAwake()) {
        return this.respawn();
      }
    };

    Ball.prototype.respawn = function() {
      var rpos;
      this.world.world.DestroyBody(this.phys);
      rpos = this.game.reflector.phys.GetWorldCenter();
      this.phys = this.world.createBall(rpos.x * 30, 550, {
        userdata: this
      });
      return this.game.fails++;
    };

    Ball.prototype.sync = function() {
      var hit, item, _ref, _results;
      item = this.phys.GetContactList();
      _results = [];
      while (item) {
        hit = (_ref = item.other.GetUserData()) != null ? _ref.ball_hit : void 0;
        if (hit != null) {
          hit.call(item.other.GetUserData(), this);
        }
        _results.push(item = item.m_next);
      }
      return _results;
    };

    return Ball;

  })();

  Clan = (function() {
    function Clan(world, ctx, img, x, y) {
      this.world = world;
      this.x = x;
      this.y = y;
      this.isClan = true;
      this.num = ~~(Math.random() * 9);
      if (this.num === 8) {
        this.altsprite = new Sprite(ctx, img, 0, 45 + 9 * 16, 20, 16);
      }
      this.sprite = new Sprite(ctx, img, 0, 45 + this.num * 16, 20, 16, 9);
      this.x = this.x * 20;
      this.y = this.y * 20;
      this.phys = this.world.createBox(this.x, this.y, 20 / 2, 15 / 2, {
        userdata: this
      });
    }

    Clan.prototype.ball_hit = function() {
      if (this.hit != null) {
        return;
      }
      this.hit = true;
      this.world.world.DestroyBody(this.phys);
      this.phys = this.world.createBox(this.x, this.y, 20 / 2, 15 / 2, {
        fixed: false,
        userdata: this
      });
      if (this.num === 8) {
        return this.sprite = this.altsprite;
      }
    };

    Clan.prototype.draw = function(ctx) {
      var pos, rot;
      pos = this.phys.GetWorldCenter();
      if (pos.y * 30 > 800) {
        this.world.world.DestroyBody(this.phys);
        return this.world.checkFinish();
      } else {
        rot = this.phys.GetAngle();
        return this.sprite.draw(ctx, pos.x, pos.y, rot);
      }
    };

    return Clan;

  })();

  Game = (function() {
    function Game(resources) {
      this.canvas = $('canvas#clanwars');
      this.canvas_bg = $('canvas#clanwars_bg');
      this.ctx = this.canvas[0].getContext('2d');
      this.ctx_bg = this.canvas_bg[0].getContext('2d');
      this.world = new World(this.ctx);
      this.load(resources, this.onload.bind(this));
      this.pressed = {};
      this.time = 0;
      this.fails = 0;
    }

    Game.prototype.clear = function() {
      return this.ctx.canvas.width = this.ctx.canvas.width;
    };

    Game.prototype.load = function(resources, cb) {
      var clans, count, interval, item, sprites, str, x, y, _i, _j, _len, _len1, _ref;
      this.ctx.canvas.width = this.ctx_bg.canvas.width = 800;
      this.ctx.canvas.height = this.ctx_bg.canvas.height = 600;
      this.cols = this.ctx.canvas.width / 20;
      this.rows = this.ctx.canvas.height / 15;
      count = 0;
      interval = setInterval((function(_this) {
        return function() {
          var i, points;
          _this.clear();
          _this.ctx.font = "30px cursive";
          points = ((function() {
            var _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = count % 4; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push('.');
            }
            return _results;
          })()).join('');
          _this.ctx.fillText("Loading" + points, 30, 50);
          return count++;
        };
      })(this), 500);
      sprites = new Image();
      sprites.onload = (function(_this) {
        return function() {
          _this.draw_bg(sprites);
          clearInterval(interval);
          return cb();
        };
      })(this);
      sprites.src = 'clanwars.png';
      this.reflector = new Reflector(this.world, this.ctx, sprites, this.cols, this.rows);
      this.ball = new Ball(this.world, this.ctx, sprites, this.cols, this.rows);
      this.reflector.ball = this.ball;
      this.ball.game = this;
      clans = [];
      _ref = map.split("\n");
      for (x = _i = 0, _len = _ref.length; _i < _len; x = ++_i) {
        str = _ref[x];
        for (y = _j = 0, _len1 = str.length; _j < _len1; y = ++_j) {
          item = str[y];
          if (item === 'Z') {
            clans.push(new Clan(this.world, this.ctx, sprites, y + 2, x));
          }
        }
      }
      this.canvas_bg.css('visibility', 'visible');
      return this.canvas.css('visibility', 'visible');
    };

    Game.prototype.tick = function() {
      var currTime, stepping, time, timeStep;
      if (this.world.finished) {
        return this.finish(this.time * 2, this.fails);
      }
      this.clear();
      currTime = Date.now();
      time = currTime - this.prevTick;
      this.prevTick = currTime;
      if (this.pressed.left) {
        this.reflector.left(time);
        this.ball.start_left();
      }
      if (this.pressed.right) {
        this.reflector.right(time);
        this.ball.start_right();
      }
      if (this.pressed.up) {
        this.reflector.up(time);
      }
      if (this.pressed.down) {
        this.reflector.down(time);
      }
      stepping = false;
      timeStep = 1 / 60;
      this.time += timeStep;
      this.world.step(timeStep, 1, 1);
      this.reflector.sync();
      this.ball.sync();
      this.world.draw(this.ctx);
      this.ctx_bg.clearRect(6, 6, 200, 200);
      this.ctx_bg.fillText("Time: " + ~~(this.time * 2), 8, 16);
      this.ctx_bg.fillText("Fails: " + this.fails, 8, 28);
      this.pressed = {};
      return requestAnimFrame((function(_this) {
        return function() {
          return _this.tick();
        };
      })(this));
    };

    Game.prototype.draw_bg = function(img) {
      var ctx, cx, h, offx, offy, w;
      ctx = this.ctx_bg;
      offx = 11;
      offy = 206;
      w = 118;
      h = 11;
      cx = 0;
      while (cx < 800) {
        ctx.drawImage(img, offx, offy, w - h, h, cx, 0, w - h, h / 2);
        cx += w - h;
      }
      ctx.rotate(Math.PI / 2);
      ctx.drawImage(img, 0, offy, h, h, 0, -11 / 2, h, h / 2);
      ctx.drawImage(img, 0, offy, h, h, 0, -800, h, h / 2);
      cx = 11 / 2;
      while (cx < 600) {
        ctx.drawImage(img, offx, offy, w - h, h, cx, -11 / 2, w - h, h / 2);
        ctx.drawImage(img, offx, offy, w - h, h, cx, -800, w - h, h / 2);
        cx += w - h;
      }
      return ctx.rotate(-Math.PI / 2);
    };

    Game.prototype.onload = function() {
      this.prevTick = Date.now();
      this.started = true;
      return this.tick();
    };

    Game.prototype.keypress = function(key) {
      if (this.started == null) {
        return;
      }
      switch (key) {
        case keys.LEFT:
          return this.pressed.left = true;
        case keys.RIGHT:
          return this.pressed.right = true;
        case keys.UP:
          return this.pressed.up = true;
        case keys.DOWN:
          return this.pressed.down = true;
      }
    };

    return Game;

  })();

  define('clanwars', function() {
    var canvas, canvas_bg, dialogs;
    canvas = $('canvas#clanwars');
    canvas.before('<canvas id="clanwars_bg" width=800 height=600></canvas>');
    canvas_bg = $('canvas#clanwars_bg');
    canvas_bg.css('background-image', 'url(clanwars-bg.jpeg)');
    canvas_bg.css('background-size', '100% 100%');
    canvas.offset(canvas_bg.offset());
    dialogs = $('#clanwars_dialogs');
    dialogs.offset(canvas_bg.offset());
    dialogs.width(800).height(600);
    return start_game_banner(dialogs, function() {
      var game, k, o, _ref;
      window.b2AABB = Box2D.Collision.b2AABB;
      window.b2Vec2 = Box2D.Common.Math.b2Vec2;
      window.b2World = Box2D.Dynamics.b2World;
      window.b2BodyDef = Box2D.Dynamics.b2BodyDef;
      window.b2Body = Box2D.Dynamics.b2Body;
      window.b2Fixture = Box2D.Dynamics.b2Fixture;
      window.b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
      window.b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
      window.b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
      window.b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
      _ref = Box2D.Dynamics.Joints;
      for (k in _ref) {
        o = _ref[k];
        window[k] = o;
      }
      game = new Game();
      $(document).keydown(function(e) {
        return game.keypress(e.keyCode);
      });
      return game.finish = function(tick, fails) {
        return finish_game_banner(dialogs, function() {
          game.clear();
          return statistics_banner(dialogs, {}, function() {});
        });
      };
    });
  });

  window.requestAnimFrame = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
      return window.setTimeout(callback, 1000 / 60);
    };
  })();

}).call(this);
